options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = true;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(XLSParser)
package Analizadores;
import ASTTree.ASTNode;
import ManejoError.TError;
import java.util.ArrayList;
import Abstract.*;
import Tablas.*;

public class XLSParser {
    int id;
    final int PUNTOCOMA = 3;
    String imgError = "";
	
	//LISTA DE ERRORES
	ArrayList<TError> errores;
	TablaSimbolos simbolos;
	
    String extractText(String text)
    {
        text = text.replace("<<", "");
        text = text.replace(">>", "");
        return text;
    }
	
	public ArrayList<TError> getErrores()
	{
		return this.errores;
	}

}

PARSER_END(XLSParser)
//ERROR
JAVACODE
void skip_error_recovery(int kind, String archivo, String columna)
{
    //ParseException e = generateParseException();  // generate the exception object.
	String ti = "Lexico";
	String m = "Caracter desconocido: ";
	Token to = getToken(1);
	if(to.kind != 27)
	{
		ti = "Sintactico";
		m = "No se esperaba: ";
		to = getToken(0);
	}
    //System.out.println("Caracter No admitido en "+archivo+", Columna: "+columna+" : "+to.image);  // print the error message
	errores.add(new TError(ti,m+to.image,columna,archivo));
    Token t;
    do {
        t = getNextToken();
    } while (t.kind != kind);
}
//PUNTUACION
TOKEN:
{
     <oKey: "{">//{//System.out.println("Token: "+image);}
    |<cKey: "}">//{//System.out.println("Token: "+image);}
    |<ptComa: ";">//{System.out.println("Token: "+image);} // ES EL 3
    |<nll: "NULL">//{System.out.println("Token: "+image);}
    |<dPts: ":">//{System.out.println("Token: "+image);}
	|<oBrack: "[">
	|<cBrack: "]">
	|<coma: ",">
}
//PALABRAS RESERVADAS CONFIGURACIONES
TOKEN:
{
     <titulo_form: "titulo_formulario">//{System.out.println("Token: "+image);}
    |<idform: "idform">//{System.out.println("Token: "+image);}
    |<estilo: "estilo">//{System.out.println("Token: "+image);}
    |<importa: "import">//{System.out.println("Token: "+image);}
    |<codigo_gl: "codigo_global">//{System.out.println("Token: "+image);}
    |<codigo_pr: "codigo_principal">//{System.out.println("Token: "+image);}
    |<conf: "_config">//{System.out.println("Token: "+image);}
	|<pag: "pagina">
	|<tod: "todo">
	|<cuadricu: "cuadricula">
}
//PALABRAS RESERVADAS PARA OPCIONES
TOKEN:
{
	 <opcions: "_opciones">
}
//PALABRAS RESERVADAS PARA ENCUESTA
TOKEN:
{
	 <pregu: "_pregunta">
	|<encus: "_Encuesta">
	|<tipo: "tipo">
	|<idpregu: "idpregunta">
	|<etiqueta: "etiqueta">
	|<sugerir: "sugerir">
	|<requerido: "requerido">
	|<requeridomsn: "requeridomsn">
	|<pordefecto: "pordefecto">
	|<lectura: "lectura">
	|<calculo: "calculo">
	|<multimedia: "multimedia">
	|<restringir: "restringir">
	|<restringirmsn: "restringirmsn">
	|<codigo_pre: "codigo_pre">
	|<codigo_post: "codigo_post">
	|<aplicable: "aplicable">
	|<apariencia: "apariencia">
	|<parametro: "parametro">
	|<verdadero: "verdadero">
	|<falso: "falso">
	|<uno: "1">
	|<cero: "0">
	|<texto: "texto">
	|<entero: "entero">
	|<decimal: "decimal">
	|<rango: "rango">
	|<condicion: "condicion">
	|<fecha: "fecha">
	|<hora: "hora">
	|<fechahora: "fechahora">
	|<sel_un: "selecciona_uno">
	|<sel_mul: "selecciona_multiples">
	|<nota: "nota">
	|<fichero: "fichero">
	|<calcular: "calcular">
}
//LOS TOKENS QUE VA A IGNORAR
SKIP:
{
    " " | "\n" | "\r" | "\r\n" | "\t" 
}
//EXPRESIONES REGULARES HASTA ABAJO
TOKEN:
{
     <identificador: ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","_","0"-"9"])*>
    |<texto_pl: "<<" ( (~["<",">"]) | ("\\" ( ["n","t","b","r","f","\\","\""] ) ) )* ">>">
    |<err: (~[])>
}
//SYNTAXIS DEL LENGUAJE

// INICIO ::= CONFIG OPCIONES ENCUESTA
ASTNode INICIO():
{
    //AQUI VAN A IR LOS HIJOS DE ESTE METODO
    id = 0;
    ASTNode padre = new ASTNode(id, 0, 0, "INICIO");
    id++;
    ASTNode confi;
	ASTNode ops;
	ASTNode enc;
	errores = new ArrayList();
	
}
{
    //LLAMADA A LOS DEMAS
    confi = CONFIG()
	ops = OPCIONES()
	enc = ENCUESTA()
    //AREA DE RETURN
    {
        //AQUI VA A IR EL RETORNO DEL PADRE
        padre.addHijo(confi);
		padre.addHijo(ops);
		padre.addHijo(enc);
        return padre;
    }
}
void EMPTY():
{}
{
	//PRODUCCION VACIA
	{
		System.out.println("VACIO");
	}
}
//-----------------------------------------------------------------------------------------------|
//---------------------- COFIG Y SUS PRDOUCCIONES------------------------------------------------|
//-----------------------------------------------------------------------------------------------|
ASTNode CONFIG():
{
    //AQUI VAN A IR LOS HIJOS DE ESTE METODO
	id++;
    ASTNode padre = new ASTNode(id, 0, 0, "CONFIG");
    
    ASTNode titulof, idf, stl, imp, cglo, cpr;
}
{
    <conf> //_config
    <oKey> //{

    titulof = TITULO()
    { padre.addHijo(titulof); }

    idf = IDFORM()
    { padre.addHijo(idf); }
    
    stl = ESTILO()
    { padre.addHijo(stl); }

    imp = IMPOR()
    { padre.addHijo(imp); }

    cglo = CGLOBAL()
    { padre.addHijo(cglo); }
    
    cpr = CPRIN()
    { padre.addHijo(cpr); }
    
    <cKey>//}
    {
        return padre;
    }
	
	|
	
	EMPTY()
	{
		return padre; 
	}
}

ASTNode TITULO():
{
    id++;
    ASTNode padre = new ASTNode(id, 0, 0, "TITULO");
    
    ASTNode tit;
}
{
    try
    {
        <titulo_form> <dPts> tit = TF("Configuraciones","titulo_formulario") <ptComa>
        {
            padre.addHijo(tit);
            return padre;
        }
    }
    catch(ParseException e)
    {
        //LLAMADA AL TOKEN DE RECUPERACION
        skip_error_recovery(PUNTOCOMA, "Configuraciones", "titulo_formulario");//hasta que encuentre el punto y coma
        return padre;
    }
}

ASTNode TF(String hoja, String columna):
{
    Token t;
}
{
    try
    {
        t = <texto_pl>
        {
            id++;
            return new ASTNode(id,0,0,extractText(t.image));
        }
    }
    catch(ParseException e)
    {
        skip_error_recovery(PUNTOCOMA, "Configuraciones", columna);//HASTA QUE ENCUENTRE EL PUNTO Y COMA
        id++;
        return new ASTNode(id, 0,0,"_ERR");
    }
        |
    try
    {
        t = <nll>
        {
            id++;
            return new ASTNode(id,0,0,t.image);
        }
    }
    catch(ParseException e)
    {
        skip_error_recovery(PUNTOCOMA, "Configuraciones", columna);//HASTA QUE ENCUENTRE EL PUNTO Y COMA
        id++;
        return new ASTNode(id, 0,0,"_ERR");
    }
}

ASTNode IDFORM():
{
    id++;
    ASTNode padre = new ASTNode(id, 0, 0, "IDFORM");
    
    ASTNode idf;
}
{
    try
    {
        <idform> <dPts> idf = IDF() <ptComa>
        {
            padre.addHijo(idf);
            return padre;
        }
    }
    catch(ParseException e)
    {
        //LLAMADA AL TOKEN DE RECUPERACION
        skip_error_recovery(PUNTOCOMA, "Configuraciones", "idformulario_");//hasta que encuentre el punto y coma
        return padre;
    }
}

ASTNode IDF():
{
    Token t;
}
{
    try
    {
        t = <identificador>
        {
            id++;
            return new ASTNode(id,0,0,t.image);
        }
    }
    catch(ParseException e)
    {
        skip_error_recovery(PUNTOCOMA, "Configuraciones", "idform");//HASTA QUE ENCUENTRE EL PUNTO Y COMA
        id++;
        return new ASTNode(id, 0,0,"_ERR");
    }
        |
    try
    {
        t = <nll>
        {
            id++;
            return new ASTNode(id,0,0,t.image);
        }
    }
    catch(ParseException e)
    {
        skip_error_recovery(PUNTOCOMA, "Configuraciones", "idform");//HASTA QUE ENCUENTRE EL PUNTO Y COMA
        id++;
        return new ASTNode(id, 0,0,"_ERR");
    }
}

ASTNode ESTILO():
{
	id++;
	ASTNode padre = new ASTNode(id, 0,0, "ESTILO");
	ASTNode est;
}
{
	try
	{
		<estilo> <dPts> est = EST() <ptComa>
		{
			padre.addHijo(est);
			return padre;
		}
	}
	catch(ParseException e)
	{
		skip_error_recovery(PUNTOCOMA, "Configuraciones", "estilo");
		return padre;
	}
}

ASTNode EST():
{
	Token t;
}
{
	try
	{
		t = <tod>
		{
			id++;
			return new ASTNode(id, 0,0, t.image);
		}
	}
	catch(ParseException e)
	{
		skip_error_recovery(PUNTOCOMA, "Configuraciones", "estilo");//HASTA QUE ENCUENTRE EL PUNTO Y COMA
		id++;
		return new ASTNode(id, 0,0,"_ERR");
	}
	|
	try
	{
		t = <pag>
		{
			id++;
			return new ASTNode(id, 0,0, t.image);
		}
	}
	catch(ParseException e)
	{
		skip_error_recovery(PUNTOCOMA, "Configuraciones", "estilo");//HASTA QUE ENCUENTRE EL PUNTO Y COMA
		id++;
		return new ASTNode(id, 0,0,"_ERR");
	}
	|
	try
	{
		t = <cuadricu>
		{
			id++;
			return new ASTNode(id, 0,0, t.image);
		}
	}
	catch(ParseException e)
	{
		skip_error_recovery(PUNTOCOMA, "Configuraciones", "estilo");//HASTA QUE ENCUENTRE EL PUNTO Y COMA
		id++;
		return new ASTNode(id, 0,0,"_ERR");
	}
}


ASTNode IMPOR():
{
	id++;
	ASTNode padre = new ASTNode(id, 0,0, "IMPORTA");
	Token t;
}
{
	try
	{
		<importa> <dPts> t = <texto_pl> <ptComa>
		{
			id++;
			padre.addHijo(new ASTNode(id,0,0, extractText(t.image)));
			return padre;
		}
 	}
	catch(ParseException e)
	{
		skip_error_recovery(PUNTOCOMA, "Configuraciones", "importar");//hasta que encuentre el punto y coma
        return padre;
	}
}

ASTNode CGLOBAL():
{
	id++;
	ASTNode padre = new ASTNode(id, 0,0, "GLOBAL");
	ASTNode temp;
}
{
	try
	{
		<codigo_gl> <dPts> temp = TF("Configuraciones","codigo_global") <ptComa>
		{
			padre.addHijo(temp);
			return padre;
		}
 	}
	catch(ParseException e)
	{
		skip_error_recovery(PUNTOCOMA, "Configuraciones", "codigo_global");//hasta que encuentre el punto y coma
        return padre;
	}
}

ASTNode CPRIN():
{
	id++;
	ASTNode padre = new ASTNode(id, 0,0, "PRINCIPAL");
	ASTNode temp;
}
{
	try
	{
		<codigo_pr> <dPts> temp = TF("Configuraciones","codigo_principal") <ptComa>
		{
			padre.addHijo(temp);
			return padre;
		}
 	}
	catch(ParseException e)
	{
		skip_error_recovery(PUNTOCOMA, "Configuraciones", "codigo_principal");//hasta que encuentre el punto y coma
        return padre;
	}
}
//-----------------------------------------------------------------------------------------------|
//---------------------- OPCIONES Y SUS PRDOUCCIONES---------------------------------------------|
//-----------------------------------------------------------------------------------------------|
ASTNode OPCIONES():
{
	id++;
	ASTNode padre = new ASTNode(id,0,0,"OPCIONES");
	ASTNode lopcs;
}
{
	try
	{
		<opcions>//_opciones
		<oKey>//{
		lopcs = L_OPCS()
		{
			padre.addHijo(lopcs);
		}
		<cKey>//}
		{
			return padre;
		}
	}
	catch(ParseException e)
	{
		return padre;
	}
	
}

ASTNode L_OPCS():
{
	id++;
	ASTNode padre = new ASTNode(id,0,0,"L_OPCS");
	ASTNode opcs;
	ASTNode l_opcs;
}
{
	opcs = OPCS()
	{padre.addHijo(opcs);}
	l_opcs = L_OPCS()
	{
		padre.addHijo(l_opcs);
		return padre;
	}
	
	|
	EMPTY()
	{
		return padre;
	}
}

ASTNode OPCS():
{
	id++;
	ASTNode padre = new ASTNode(id,0,0,"OPCS");
	Token t;
	ASTNode l_entrada;
}
{
	try
	{
		t = <identificador> <oKey> l_entrada = L_ENT() <cKey> <ptComa>
		{
			id++;
			padre.addHijo(new ASTNode(id,0,0,t.image));
			padre.addHijo(l_entrada);
			return padre;
		}
		|
		<nll>
		{
			//AQUI MENCIONAR EL ERROR DE LISTA
			skip_error_recovery(PUNTOCOMA, "Opciones", "nombre_lista");
			errores.add(new TError("Sintactico","Nombre de listado Invalido: NULL | Se esperaba un Id", "nombre_lista", "Opciones"));
			return padre;
		}
	}
	catch(ParseException e)
	{
		skip_error_recovery(PUNTOCOMA, "Opciones", "nombre_lista");//hasta que encuentre el punto y coma
		return padre;
	}
}

ASTNode L_ENT():
{
	id++;
	ASTNode padre = new ASTNode(id,0,0,"L_ENT");
	ASTNode ent;
	ASTNode l_ent;
}
{
	ent = ENT()
	l_ent = L_ENT()
	{	
		padre.addHijo(ent); 
		padre.addHijo(l_ent);
		return padre;
	}
	|
	EMPTY()
	{return padre;}
}

ASTNode ENT():
{
	id++;
	ASTNode padre = new ASTNode(id,0,0,"ENT");
	Token iden;
	Token cad;
	ASTNode mult;
}
{
	try
	{
		<oBrack> iden = <identificador> <coma> cad = <texto_pl> <coma> mult = TF("Opciones","multimedia") <cBrack>
		{
			id++;
			padre.addHijo(new ASTNode(id,0,0,iden.image));
			id++;
			padre.addHijo(new ASTNode(id,0,0,extractText(cad.image)));
			padre.addHijo(mult);
			return padre;
		}
	}
	catch(ParseException e)
	{
		skip_error_recovery(PUNTOCOMA, "Opciones", "nombre");//hasta que encuentre el punto y coma
		return padre;
	}
}
//-----------------------------------------------------------------------------------------------|
//---------------------- ENCUESTA Y SUS PRDOUCCIONES---------------------------------------------|
//-----------------------------------------------------------------------------------------------|
ASTNode ENCUESTA():
{
	id++;
	ASTNode padre = new ASTNode(id,0,0,"ENCUESTA");
	simbolos = new TablaSimbolos();
	Formulario f = new Formulario();
}
{
	<encus> <oKey>
	f = ENCUESTAP(f)
	<cKey>
	{
		padre.setForm(f);
		this.simbolos.printCountElements();
		return padre;
	}
	
}

Formulario ENCUESTAP(Formulario f):
{
	Pregunta p;
	Grupo g;
	Ciclo c;
}
{
	p = PREGUNTA() f = ENCUESTAP(f)
	{
		if(p!=null)
		{
			f.addPregunta(p);
		}
		return f;
	}
	|EMPTY()
	{
		return f;
	}
}

Pregunta PREGUNTA():
{
	int ti;
	Token iden;
	Token cad;
}
{
	try
	{
		<pregu> <oKey> <tipo> <dPts>  ti = TIPO() <ptComa> <idpregu> <dPts> iden = <identificador> <ptComa> <etiqueta> <dPts> cad = <texto_pl> <ptComa> <cKey>
		{
			
			Pregunta p = new Pregunta(iden.image, extractText(cad.image), ti);
			if(simbolos.insertaEnTabla(iden.image, new Simbolo(iden.image, "Pregunta", p)))
			{
				return p;
			}
			this.errores.add(new TError("Semantico", "Existe ya un Simbolo con este identificador: "+iden.image,"idpregunta", "Encuesta"));
			return null;
		}
	}
	catch(ParseException e)
	{
		skip_error_recovery(PUNTOCOMA, "Encuesta", "idpregunta, etiqueta");
		return null;
	}
}

int TIPO():
{
	
}
{
	try
	{
		 <texto>
		 {return TipoPregunta.TEXTO;}
		
		|<entero>
		{return TipoPregunta.ENTERO;}
		
		|<decimal>
		{return TipoPregunta.DECIMAL;}
		
		|<rango>
		{return TipoPregunta.RANGO;}
		
		|<condicion>
		{return TipoPregunta.CONDICION;}
		
		|<fecha>
		{return TipoPregunta.FECHA;}
		
		|<hora>
		{return TipoPregunta.HORA;}
		
		|<fechahora>
		{return TipoPregunta.FECHAHORA;}
		
		|<sel_un>
		{return TipoPregunta.SELEC_UNO;}
		
		|<sel_mul>
		{return TipoPregunta.SELEC_MULT;}
		
		|<nota>
		{return TipoPregunta.NOTA;}
		
		|<fichero>
		{return TipoPregunta.FICHERO;}
		
		|<calcular>
		{return TipoPregunta.CALCULAR;}
		
	}
	catch(ParseException e)
	{
		skip_error_recovery(PUNTOCOMA,"Encuesta", "Tipo");
		return 14;
	}
}

